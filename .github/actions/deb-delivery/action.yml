name: "deb-delivery"
description: "Package deb packages"
inputs:
  module_name:
    description: "The package module name"
    required: true
  distrib:
    description: "The distribution used for packaging"
    required: true
  version:
    description: "Centreon packaged major version"
    required: true
  cache_key:
    description: "The cached package key"
    required: true
  stability:
    description: "The package stability (stable, testing, unstable)"
    required: true
  artifactory_token:
    description: "Artifactory token"
    required: true
  release_type:
    description: "Type of release (hotfix, release)"
    required: true
  is_cloud:
    description: "Release context (cloud or not cloud)"
    required: true

runs:
  using: "composite"
  steps:
    - name: Use cache DEB files
      uses: actions/cache/restore@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3
      with:
        path: ./*.deb
        key: ${{ inputs.cache_key }}
        fail-on-cache-miss: true

    - uses: jfrog/setup-jfrog-cli@45d604504ed4cf717138383936c447afab73a0be # v4.5.10
      env:
        JF_URL: https://centreon.jfrog.io
        JF_ACCESS_TOKEN: ${{ inputs.artifactory_token }}

    - name: Publish DEBs
      run: |
        FILES="*.deb"

        # DEBUG
        echo "[DEBUG] - Version: ${{ inputs.version }}"
        echo "[DEBUG] - Distrib: ${{ inputs.distrib }}"
        echo "[DEBUG] - module_name: ${{ inputs.module_name }}"
        echo "[DEBUG] - is_cloud: ${{ inputs.is_cloud }}"
        echo "[DEBUG] - release_type: ${{ inputs.release_type }}"
        echo "[DEBUG] - stability: ${{ inputs.stability }}"

        # Make sure all required inputs are NOT empty
        if [[ -z "${{ inputs.module_name }}" || -z "${{ inputs.distrib }}" || -z ${{ inputs.stability }} || -z ${{ inputs.version }} || -z "${{ inputs.is_cloud }}" ]]; then
          echo "Some mandatory inputs are empty, please check the logs."
          exit 1
        fi

        # Set ROOT_REPO_PATH based on inputs
        if [[ "${{ inputs.is_cloud }}" == "true" ]]; then
            ROOT_REPO_PATH="apt-standard-internal-${{ inputs.stability }}"
        elif [[ "${{ inputs.distrib }}" == "jammy" ]]; then
          ROOT_REPO_PATH="ubuntu-standard-${{ inputs.version }}-${{ inputs.stability }}"
        else
          ROOT_REPO_PATH="apt-standard-${{ inputs.version }}-${{ inputs.stability }}"
        fi

        # Cleanup (equivalent to --sync-deletes done with RPMs)
        # This is a workaround the fact that jfrog cli does not allow upload
        # of multiple artifacts at once to an APT repository

        # # Get list of all remote artifacts in component dir
        # ARTIFACTS_REMOTE_LIST=$(jf rt search "$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/*.deb" --recursive --sort-by=path |jq -r .[].path)

        # # Get list of local artifacts with path
        # for file in $(dir -1 |grep -E '*\.deb'); do
        #   ARTIFACTS_LOCAL_LIST+=("$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/$file")
        # done

        # #ARTIFACTS_LOCAL_LIST=$(dir -1 |grep -E '*\.deb')

        # # Build list of diff between local and remote artifacts
        # for local_artifact in "${ARTIFACTS_LOCAL_LIST[@]}"; do
        #   found=false
        #   # Iterate over elements of ARTIFACTS_REMOTE_LIST
        #   for remote_artifact in "${ARTIFACTS_REMOTE_LIST[@]}"; do
        #     # Compare elements
        #     if [ "$local_artifact" == "$remote_artifact" ]; then
        #       found=true
        #       break
        #     fi
        #   done
        #   # If element not found in ARTIFACTS_REMOTE_LIST, add it to ARTIFACTS_DIFF_LIST
        #   if ! $found; then
        #     ARTIFACTS_DIFF_LIST+=("$local_artifact")
        #   fi
        # done

        # # DEBUG ARTIFACTS_DIFF_LIST
        # echo ${ARTIFACTS_DIFF_LIST[*]}

        # # Delete all remote artifacts
        # #jf rt delete "$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/*.deb"

        # # Upload local artifacts
        # for ARTIFACT in ${ARTIFACTS_LOCAL_LIST[@]}; do
        #   echo "[DEBUG] - File: $ARTIFACT"

        #   VERSION=${{ inputs.major_version }}
        #   DISTRIB=$(echo $ARTIFACT | cut -d '_' -f2 | cut -d '-' -f2)
        #   ARCH=$(echo $ARTIFACT | cut -d '_' -f3 | cut -d '.' -f1)

        #   echo "[DEBUG] - Version: $VERSION"

        #   # Delete all remote artifacts that have the same ARTIFACT_BASENAME + DISTRIB + ARCH
        #   ARTIFACT_BASENAME=$(echo "$ARTIFACT" | cut -d '_' -f 1)
        #   echo "[DEBUG] - Deleting remote artifact $ROOT_REPO_PATH/pool/${{ inputs.module_name }}/$ARTIFACT_BASENAME*$DISTRIB*$ARCH.deb"
        #   jf rt delete "$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/$ARTIFACT_BASENAME*$DISTRIB*$ARCH.deb"

        #   jf rt upload "$ARTIFACT" "$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/" --deb "${{ inputs.distrib }}/main/$ARCH"
        # done


        # for each local artifact
        # build a path using ARTIFACT_BASENAME+OS_DISTRIB+ARCH
        # search and delete remote artifact that has the same ARTIFACT_BASENAME+OS_DISTRIB+ARCH
        # upload local artifact

        # For each local artifact
        for file in $FILES; do
          # build a search pattern using ARTIFACT_BASENAME+OS_DISTRIB+ARCH
          VERSION=${{ inputs.major_version }}
          BASENAME=$(echo "$file" | cut -d '_' -f 1)
          OS_DISTRIB=$(echo "$file" | sed -n 's/.*+\(deb[0-9]\+\).*/\1/p')
          ARCH=$(echo $file | cut -d '_' -f3 | cut -d '.' -f1)

          # debug
          echo "[DEBUG] - Version: $VERSION"
          echo "[DEBUG] - Basename: $BASENAME"
          echo "[DEBUG] - OS_distrib: $OS_DISTRIB"
          echo "[DEBUG] - Arch: $ARCH"

          SEARCH_PATH="$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/$BASENAME*OS_DISTRIB*ARCH*.deb"

          # search and delete all remote artifacts matching this pattern
          echo "Searching and deleting $SEARCH_PATH"
          jf rt delete "$SEARCH_PATH"

          # upload local artifact
          echo "Uploading $file"
          jf rt upload "$file" "$ROOT_REPO_PATH/pool/${{ inputs.module_name }}/" --deb "${{ inputs.distrib }}/main/$ARCH"
        done
      shell: bash
